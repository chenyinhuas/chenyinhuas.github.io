{"title":"tsconfig.json 编译配置","uid":"56833ebc3b5ebf1e1226fc895706e9a1","slug":"typescript/tsconfig.json 编译配置","date":"2022-03-05T08:40:02.000Z","updated":"2023-01-04T12:47:40.221Z","comments":true,"path":"api/articles/typescript/tsconfig.json 编译配置.json","keywords":null,"cover":"https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png","content":"<h1 id=\"tsconfig-json-编译配置\"><a href=\"#tsconfig-json-编译配置\" class=\"headerlink\" title=\"tsconfig.json 编译配置\"></a>tsconfig.json 编译配置</h1><pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\">&#123;\n  &#x2F;&#x2F; 设置保存文件的时候自动编译，但需要编译器支持。\n  &quot;compileOnSave&quot;: false,\n\n  &#x2F;&#x2F; 编译选项配置\n  &quot;compilerOptions&quot;: &#123;\n    &quot;incremental&quot;: true, &#x2F;&#x2F; TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度\n\n    &quot;tsBuildInfoFile&quot;: &quot;.&#x2F;buildFile&quot;, &#x2F;&#x2F; 增量编译文件的存储位置\n\n    &quot;diagnostics&quot;: true, &#x2F;&#x2F; 打印诊断信息\n\n    &quot;target&quot;: &quot;ES5&quot;, &#x2F;&#x2F; 目标语言的版本\n\n    &quot;module&quot;: &quot;CommonJS&quot;, &#x2F;&#x2F; 生成代码的模板标准\n\n    &quot;outFile&quot;: &quot;.&#x2F;app.js&quot;, &#x2F;&#x2F; 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置&quot;module&quot;: &quot;AMD&quot;,\n\n    &quot;lib&quot;: [&quot;DOM&quot;, &quot;ES2015&quot;, &quot;ScriptHost&quot;, &quot;ES2019.Array&quot;], &#x2F;&#x2F; TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入&quot;ES2019.Array&quot;,\n\n    &quot;allowJS&quot;: true, &#x2F;&#x2F; 允许编译器编译JS，JSX文件\n\n    &quot;checkJs&quot;: true, &#x2F;&#x2F; 允许在JS文件中报错，通常与allowJS一起使用\n\n    &quot;outDir&quot;: &quot;.&#x2F;dist&quot;, &#x2F;&#x2F; 指定输出目录\n\n    &quot;rootDir&quot;: &quot;.&#x2F;&quot;, &#x2F;&#x2F; 指定输出文件目录(用于输出)，用于控制输出目录结构\n\n    &quot;declaration&quot;: true, &#x2F;&#x2F; 生成声明文件，开启后会自动生成声明文件\n\n    &quot;declarationDir&quot;: &quot;.&#x2F;file&quot;, &#x2F;&#x2F; 指定生成声明文件存放目录\n\n    &quot;emitDeclarationOnly&quot;: true, &#x2F;&#x2F; 只生成声明文件，而不会生成js文件\n\n    &quot;sourceMap&quot;: true, &#x2F;&#x2F; 生成目标文件的sourceMap文件\n\n    &quot;inlineSourceMap&quot;: true, &#x2F;&#x2F; 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中\n\n    &quot;declarationMap&quot;: true, &#x2F;&#x2F; 为声明文件生成sourceMap\n\n    &quot;typeRoots&quot;: [], &#x2F;&#x2F; 声明文件目录，默认时node_modules&#x2F;@types\n\n    &quot;types&quot;: [], &#x2F;&#x2F; 加载的声明文件包\n\n    &quot;removeComments&quot;:true, &#x2F;&#x2F; 删除注释\n\n    &quot;noEmit&quot;: true, &#x2F;&#x2F; 不输出文件,即编译后不会生成任何js文件\n\n    &quot;noEmitOnError&quot;: true, &#x2F;&#x2F; 发送错误时不输出任何文件\n\n    &quot;noEmitHelpers&quot;: true, &#x2F;&#x2F; 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用\n\n    &quot;importHelpers&quot;: true, &#x2F;&#x2F; 通过tslib引入helper函数，文件必须是模块\n\n    &quot;downlevelIteration&quot;: true, &#x2F;&#x2F; 降级遍历器实现，如果目标源是es3&#x2F;5，那么遍历器会有降级的实现\n\n    &quot;strict&quot;: true, &#x2F;&#x2F; 开启所有严格的类型检查\n\n    &quot;alwaysStrict&quot;: true, &#x2F;&#x2F; 在代码中注入&#39;use strict&#39;\n\n    &quot;noImplicitAny&quot;: true, &#x2F;&#x2F; 不允许隐式的any类型\n\n    &quot;strictNullChecks&quot;: true, &#x2F;&#x2F; 不允许把null、undefined赋值给其他类型的变量\n\n    &quot;strictFunctionTypes&quot;: true, &#x2F;&#x2F; 不允许函数参数双向协变\n\n    &quot;strictPropertyInitialization&quot;: true, &#x2F;&#x2F; 类的实例属性必须初始化\n\n    &quot;strictBindCallApply&quot;: true, &#x2F;&#x2F; 严格的bind&#x2F;call&#x2F;apply检查\n\n    &quot;noImplicitThis&quot;: true, &#x2F;&#x2F; 不允许this有隐式的any类型\n\n    &quot;noUnusedLocals&quot;: true, &#x2F;&#x2F; 检查只声明、未使用的局部变量(只提示不报错)\n\n    &quot;noUnusedParameters&quot;: true, &#x2F;&#x2F; 检查未使用的函数参数(只提示不报错)\n\n    &quot;noFallthroughCasesInSwitch&quot;: true, &#x2F;&#x2F; 防止switch语句贯穿(即如果没有break语句后面不会执行)\n\n    &quot;noImplicitReturns&quot;: true, &#x2F;&#x2F;每个分支都会有返回值\n\n    &quot;esModuleInterop&quot;: true, &#x2F;&#x2F; 允许export&#x3D;导出，由import from 导入\n\n    &quot;allowUmdGlobalAccess&quot;: true, &#x2F;&#x2F; 允许在模块中全局变量的方式访问umd模块\n\n    &quot;moduleResolution&quot;: &quot;node&quot;, &#x2F;&#x2F; 模块解析策略，ts默认用node的解析策略，即相对的方式导入\n\n    &quot;baseUrl&quot;: &quot;.&#x2F;&quot;, &#x2F;&#x2F; 解析非相对模块的基地址，默认是当前目录\n\n    &quot;paths&quot;: &#123; &#x2F;&#x2F; 路径映射，相对于baseUrl\n      &#x2F;&#x2F; 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置\n      &quot;jquery&quot;: [&quot;node_modules&#x2F;jquery&#x2F;dist&#x2F;jquery.min.js&quot;]\n    &#125;,\n\n    &quot;rootDirs&quot;: [&quot;src&quot;,&quot;out&quot;], &#x2F;&#x2F; 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错\n\n    &quot;listEmittedFiles&quot;: true, &#x2F;&#x2F; 打印输出文件\n\n    &quot;listFiles&quot;: true&#x2F;&#x2F; 打印编译的文件(包括引用的声明文件)\n  &#125;,\n\n  &#x2F;&#x2F; include 属性作用是指定编译需要编译的文件或目录。\n  &quot;include&quot;: [&quot;.&#x2F;src&#x2F;**&#x2F;*&quot;],\n\n  &#x2F;&#x2F; exclude 属性作用是指定编译器需要排除的文件或文件夹。默认排除 node_modules 文件夹下文件。\n  &quot;exclude&quot;: [&quot;.&#x2F;utils&#x2F;**&#x2F;*&quot;],\n\n  &#x2F;&#x2F; extends 属性作用是引入其他配置文件，继承配置。\n  &quot;extends&quot;: &quot;.&#x2F;tsconfig.base.json&quot;,\n\n  &#x2F;&#x2F; files 属性作用是指定需要编译的单个文件列表。 默认包含当前目录和子目录下所有 TypeScript 文件。\n  &quot;files&quot;: [\n    &#x2F;&#x2F; 指定编译文件是src目录下的leo.ts文件\n    &quot;scr&#x2F;leo.ts&quot;\n  ],\n\n  &#x2F;&#x2F; references 属性作用是指定工程引用依赖。\n  &#x2F;&#x2F; 在项目开发中，有时候我们为了方便将前端项目和后端node项目放在同一个目录下开发，两个项目依赖同一个配置文件和通用文件，但我们希望前后端项目进行灵活的分别打包，那么我们可以进行如下配置：\n  &quot;references&quot;: [ &#x2F;&#x2F; 指定依赖的工程\n    &#123;&quot;path&quot;: &quot;.&#x2F;common&quot;&#125;\n  ],\n\n  &#x2F;&#x2F; typeAcquisition 属性作用是设置自动引入库类型定义文件(.d.ts)相关。\n  &#x2F;&#x2F; enable  : 布尔类型，是否开启自动引入库类型定义文件(.d.ts)，默认为 false；\n  &#x2F;&#x2F; include  : 数组类型，允许自动引入的库名，如：[&quot;jquery&quot;, &quot;lodash&quot;]；\n  &#x2F;&#x2F; exculde  : 数组类型，排除的库名。\n  &quot;typeAcquisition&quot;: &#123;\n    &quot;enable&quot;: false,\n    &quot;exclude&quot;: [&quot;jquery&quot;],\n    &quot;include&quot;: [&quot;jest&quot;]\n  &#125;\n&#125;</code></pre>\n","text":"tsconfig.json 编译配置&#123; &#x2F;&#x2F; 设置保存文件的时候自动编译，但需要编译器支持。 &quot;compileOnSave&quot;: false, &#x2F;&#x2F; 编译选项配置 &quot;compilerOptions&qu...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"TypeScript","slug":"TypeScript","count":3,"path":"api/categories/TypeScript.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":3,"path":"api/tags/TypeScript.json"},{"name":"tsconfig","slug":"tsconfig","count":1,"path":"api/tags/tsconfig.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#tsconfig-json-%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">tsconfig.json 编译配置</span></a></li></ol>","author":{"name":"木木木","slug":"blog-author","avatar":"https://homeimage.hoiyee.net/lbs/2023-1-3/ywa8wim0wn_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230103144606.jpg","link":"/","description":"一位正在重塑和新增知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"TypeScript的数据类型","uid":"2eed4986ddc0b5ad3de17ce564c45e28","slug":"typescript/TypeScript的数据类型","date":"2022-03-05T08:47:36.000Z","updated":"2023-01-04T12:47:40.221Z","comments":true,"path":"api/articles/typescript/TypeScript的数据类型.json","keywords":null,"cover":"https://s2.loli.net/2023/01/03/yaCgTcBLzJk1672.png","text":"TypeScript的数据类型 变量一但定义了某个数据类型后就不允许赋值其他数据类型的数值了 基础数据类型numberstringbooleanvoidnullundefindedany (使用 TS 时不建议使用 any 类型)&#x2F;&#x2F; 声明类型时如果不指定类型...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"TypeScript","slug":"TypeScript","count":3,"path":"api/categories/TypeScript.json"}],"tags":[{"name":"TypeScript","slug":"TypeScript","count":3,"path":"api/tags/TypeScript.json"},{"name":"数据类型","slug":"数据类型","count":1,"path":"api/tags/数据类型.json"}],"author":{"name":"木木木","slug":"blog-author","avatar":"https://homeimage.hoiyee.net/lbs/2023-1-3/ywa8wim0wn_%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230103144606.jpg","link":"/","description":"一位正在重塑和新增知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}