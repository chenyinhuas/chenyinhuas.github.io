{"title":"大常用的聚合函数","uid":"e2cddd99de188368b93b43730ab7c3b6","slug":"MySQL/大常用的聚合函数","date":"2023-01-04T13:43:16.862Z","updated":"2023-01-04T13:47:03.518Z","comments":true,"path":"api/articles/MySQL/大常用的聚合函数.json","keywords":null,"cover":"https://files.catbox.moe/l8sn6i.png","content":"<h1 id=\"大常用的聚合函数\"><a href=\"#大常用的聚合函数\" class=\"headerlink\" title=\"大常用的聚合函数\"></a>大常用的聚合函数</h1><h2 id=\"常见的几个聚合函数：\"><a href=\"#常见的几个聚合函数：\" class=\"headerlink\" title=\"常见的几个聚合函数：\"></a>常见的几个聚合函数：</h2><h6 id=\"只适用于数值类型的字段（或变量）\"><a href=\"#只适用于数值类型的字段（或变量）\" class=\"headerlink\" title=\"# 只适用于数值类型的字段（或变量）\"></a># 只适用于数值类型的字段（或变量）</h6><pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">AVG（平均值） &#x2F;  SUM（求和）</code></pre>\n\n<pre class=\"line-numbers language-latex\" data-language=\"latex\"><code class=\"language-latex\">#如何需要统计表中的记录数,使用COUNT (*)、COUNT (1)、COUNT (具体字段)哪个效率更高呢?*\n\n#如果使用的是MyISAM存储引擎,则三者效率相同,都是0(1)*\n\n#如果使用的是InnoDB存储引擎,则三者效率: COUNT (*) &#x3D; COUNT (1)&gt; COUNT (字段)</code></pre>\n\n<h6 id=\"适用于数值类型，字符串类型，日期时间类型的字段（或变量）\"><a href=\"#适用于数值类型，字符串类型，日期时间类型的字段（或变量）\" class=\"headerlink\" title=\"# 适用于数值类型，字符串类型，日期时间类型的字段（或变量）\"></a># 适用于数值类型，字符串类型，日期时间类型的字段（或变量）</h6><pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">MAX（最大值）&#x2F;   MIN（最小值）</code></pre>\n\n<h6 id=\"作用：计算指定字段在查询结构中出现的个数（不计算NULL值的）。公式：AVG-SUM-COUNT\"><a href=\"#作用：计算指定字段在查询结构中出现的个数（不计算NULL值的）。公式：AVG-SUM-COUNT\" class=\"headerlink\" title=\"# 作用：计算指定字段在查询结构中出现的个数（不计算NULL值的）。公式：AVG = SUM / COUNT\"></a># 作用：计算指定字段在查询结构中出现的个数（不计算NULL值的）。公式：AVG = SUM / COUNT</h6><pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">COUNT（统计）</code></pre>\n\n<h6 id=\"基本使用：GROUP-BY\"><a href=\"#基本使用：GROUP-BY\" class=\"headerlink\" title=\"# 基本使用：GROUP  BY\"></a># 基本使用：GROUP  BY</h6><pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">SELECT 列名 FROM 表名 GROUP BY 列名;</code></pre>\n\n<h6 id=\"使用多个列分组：GROUP-BY\"><a href=\"#使用多个列分组：GROUP-BY\" class=\"headerlink\" title=\"# 使用多个列分组：GROUP  BY\"></a># 使用多个列分组：GROUP  BY</h6><pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">SELECT 列名 FROM 表名 GROUP BY 列名,列名;\nSELECT 列名 FROM 表名 GROUP BY 列名 WITH ROLLUP; # WITH ROLLUP(整和)</code></pre>\n\n<pre class=\"line-numbers language-latex\" data-language=\"latex\"><code class=\"language-latex\">结论1：SELECT中出现的非组函数的字段必须声明在GROUP BY 中。\n       反之，在GROUP BY中声明的字段可以不出现在SELECT中。\n结论2：GROUP BY 声明在FROM后面、WHERE前面、ORDER BY 前面、LIMIT前面。\n结论3：MySQL中GROUP BY 中使用WITH ROLLUP（整和）。\n说明:  当使用ROLLUP时,不能同时使用ORDER BY子句进行结果排序,即ROLLUP和ORDER BY是互相排斥的。</code></pre>\n\n<h6 id=\"HAVING-的使用\"><a href=\"#HAVING-的使用\" class=\"headerlink\" title=\"# HAVING() 的使用\"></a># HAVING() 的使用</h6><pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">SELECT * FROM 表名 GROUP BY 列名 HAVING 过滤条件;\n# 方式1：推荐使用，执行效率高于方式2。\nSELECT 列名,MAX(列名)\nFROM 表名\nWHERE 列名 IN ();\nGROUP BY 列名\nHAVING MAX() &gt; 1000;\n# 方式2：\nSELECT 列名,MAX(列名)\nWHERE 列名 IN ();\nGROUP BY 列名\nHAVING MAX() &gt; 1000 AND 列名 IN ();\n# 结论：当过滤条件中有聚合函数时，则此过滤条件必须声明在HAVING中。\n#       当过滤条件中没有聚合函数时，则此过滤条件声明在WHERE中或HAVING中都可以。但是，建议大家声明在WHERE中。</code></pre>\n\n<pre class=\"line-numbers language-latex\" data-language=\"latex\"><code class=\"language-latex\"># 作用：用来过滤数据。\n# 要求1：如果过滤条件中使用了聚合函数，则必须使用HAVING来替换WHERE。否则，报错。\n# 要求2：HAVING 必须声明在 GROUP BY 的后面。\n# 要求3：开发中，我们使用HAVGING的提前是SQL中使用了GROUP BY。</code></pre>\n\n<pre class=\"line-numbers language-latex\" data-language=\"latex\"><code class=\"language-latex\">WHERE 与 HAVING 的对比。\n1.从适用范围上来讲,HAVING的适用范围更广。\n2.如果过滤条件中没有聚合函数：这种情况下, WHERE的执行效率要高于HAVING。\n小结：\nWHERE\n优点：先筛选数据再关联,执行效率高。\n缺点：不能使用分组中的计算函数进行筛选。\nHAVING\n优点：可以使用分组中的计算函数。\n缺点：在最后的结果集中进行筛选,执行效率较低。</code></pre>\n\n<h6 id=\"SQL底层执行原理：\"><a href=\"#SQL底层执行原理：\" class=\"headerlink\" title=\"SQL底层执行原理：\"></a>SQL底层执行原理：</h6><pre class=\"line-numbers language-latex\" data-language=\"latex\"><code class=\"language-latex\">1.SELECT 语句的完整结构\n\nSQL92语法：\nSELECT ...,...,...(存在聚合函数)\nFROM ...,...,...\nWHERE 多表的连接条件 AND 不包含聚合函数的过滤条件\nGROUP BY ...,... \nHAVING 包含聚合函数的过滤条件\nORDER BY ...,...(ASC&#x2F;DESC)\nLIMIT ...,...\n\nSQL99语法：\nSELECT ...,...,...(存在聚合函数)\nFROM ... (LEFT &#x2F; RIGHT)JOIN ... ON ... 多表的连接条件 (LEFT &#x2F; RIGHT)JOIN ... ON ...\nWHERE 不包含聚合函数的过滤条件\nGROUP BY ...,... \nHAVING 包含聚合函数的过滤条件\nORDER BY ...,...(ASC&#x2F;DESC)\nLIMIT ...,...\n</code></pre>\n\n\n\n<h1 id=\"存储过程\"><a href=\"#存储过程\" class=\"headerlink\" title=\"存储过程\"></a>存储过程</h1><pre class=\"line-numbers language-latex\" data-language=\"latex\"><code class=\"language-latex\">存储过程（没有返回值）\n含义:存储过程的英文是Stored Procedure。它的思想很简单,就是一组经过预先编译的SQL语句的封装。\n执行过程:存储过程预先存储在MySQL服务器上,需要执行的时候,客户端只需要向服务器端发出调用存储过程的命令,服务器端就可以把预先存储好的这一系列SQL语句全部执行。</code></pre>\n\n<h6 id=\"1-创建存储过程\"><a href=\"#1-创建存储过程\" class=\"headerlink\" title=\"1.创建存储过程\"></a>1.创建存储过程</h6><p>1.1语法分析</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">CREATE（创建） PROCEDURE（需要创建的东西：存储） 存储过程名(（无指定，则默认类型IN）IN|OUT|INOUT 参数名 参数类型,...)\n[characteristics（特征） ...]\nBEGIN\n    存储过程\n|\nEND</code></pre>\n\n<pre class=\"line-numbers language-latex\" data-language=\"latex\"><code class=\"language-latex\">LANGUAGE SQL：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。</code></pre>\n\n\n\n<p>1.2分类</p>\n<pre class=\"line-numbers language-latex\" data-language=\"latex\"><code class=\"language-latex\">存储过程的参数类型可以是IN、OUT和INOUT。根据这点分类如下：\n1、没有参数（无参数无返回）\n2、仅仅带IN类型（有参数无返回）\n3、仅仅带OUT类型（无参数有返回）\n4、既带IN又带OUT（有参数有返回）\n5、带INOUT（有参数有返回）\n注意：IN、OUT、INOUT都可以在一个存储过程中带多个。</code></pre>\n\n<h6 id=\"2-设置结束符合\"><a href=\"#2-设置结束符合\" class=\"headerlink\" title=\"2.设置结束符合\"></a>2.设置结束符合</h6><pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">DELIMITER $、&#x2F;&#x2F;、;(输入自定义结尾的符号)</code></pre>\n\n\n\n<h6 id=\"3-存储过程的调用\"><a href=\"#3-存储过程的调用\" class=\"headerlink\" title=\"3.存储过程的调用\"></a>3.存储过程的调用</h6><pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">CALL 存储过程名();</code></pre>\n\n<h1 id=\"存储函数的使用（用户自定义的使用）\"><a href=\"#存储函数的使用（用户自定义的使用）\" class=\"headerlink\" title=\"存储函数的使用（用户自定义的使用）\"></a>存储函数的使用（用户自定义的使用）</h1><p>1.语法分析</p>\n<p>语法格式：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">CREATE FUNCTION 函数名(参数名 参数类型,...)\n\nRETURNS 返回值类型（函数一定是有返回值的）\n\n[characteristics（创建函数时的一个约束） ...]\n\nBEGIN（开始）\n\n​          函数体 # 函数体中肯定有 RETURN 语句，表示这个函数一定会返回一个什么结果给到\n\nEND （结束）</code></pre>\n\n<pre class=\"line-numbers language-latex\" data-language=\"latex\"><code class=\"language-latex\">*注意：\n若在创建存储函数中报错“you might want to use the less safe log_bin_trust_function_creators_variable”,有两种处理方法：\n· 方式一：加上必要的函数特性“[NOT]DETERMINISTIC(确定性的)”和“&#123;CONTAINS SQL(包含sql) | NO SQL(没有sql) | READS SQL DATA(读取sql) | MODIFIES SQL DATA(写sql数据)&#125;”\n· 方式二：mysql &gt; SET GLOBAL log_bin_trust_function_creators &#x3D; 1;</code></pre>\n\n<h2 id=\"对比存储函数和存储过程\"><a href=\"#对比存储函数和存储过程\" class=\"headerlink\" title=\"对比存储函数和存储过程\"></a>对比存储函数和存储过程</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">存储过程：\n关键字：PROCEDURE\n调用语法：CALL存储过程()\n返回值：理解为有0个或多个\n应用场景：一般用于更新</code></pre>\n\n<pre class=\"line-numbers language-latex\" data-language=\"latex\"><code class=\"language-latex\">存储函数:\n关键字：FUNCTION\n调用语法：SELECT函数()\n返回值：只能是一个\n应用场景：一般用于查询结果为一个值并返回时</code></pre>\n\n<p>此外，<em>存储函数可以放在查询语句中使用，存储过程不行。</em>反之，存储过程的功能更加强大，包括能够执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的。</p>\n<p>关于存储过程使用的争议 </p>\n<p>一、优点（避免重复性，增加使用性）</p>\n<ol>\n<li>存储过程可以一次编译多次使用。</li>\n<li>可以减少开发工作量。</li>\n<li>存储过程的安全性强。</li>\n<li>可以减少网络传输量。</li>\n</ol>\n<p>二、缺点（存储过程难以调试和扩展，更没有移植性？）</p>\n<p>可移植性差。</p>\n<p>调试困难。</p>\n<p>存储过程的版本管理很困难。</p>\n<p>它不适合高并发的场景。</p>\n","feature":true,"text":"大常用的聚合函数常见的几个聚合函数：# 只适用于数值类型的字段（或变量）AVG（平均值） &#x2F; SUM（求和） #如何需要统计表中的记录数,使用COUNT (*)、COUNT (1)、COUNT (具体字段)哪个效率更高呢?* #如果使用的是MyISAM存储引擎,则三者效...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"MYSQL","slug":"MYSQL","count":3,"path":"api/categories/MYSQL.json"}],"tags":[{"name":"MYSQL","slug":"MYSQL","count":2,"path":"api/tags/MYSQL.json"},{"name":"聚合函数","slug":"聚合函数","count":1,"path":"api/tags/聚合函数.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%9A%84%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">大常用的聚合函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E4%B8%AA%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%EF%BC%9A\"><span class=\"toc-text\">常见的几个聚合函数：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%8F%AA%E9%80%82%E7%94%A8%E4%BA%8E%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E6%AE%B5%EF%BC%88%E6%88%96%E5%8F%98%E9%87%8F%EF%BC%89\"><span class=\"toc-text\"># 只适用于数值类型的字段（或变量）</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E9%80%82%E7%94%A8%E4%BA%8E%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E6%AE%B5%EF%BC%88%E6%88%96%E5%8F%98%E9%87%8F%EF%BC%89\"><span class=\"toc-text\"># 适用于数值类型，字符串类型，日期时间类型的字段（或变量）</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E5%9C%A8%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BC%88%E4%B8%8D%E8%AE%A1%E7%AE%97NULL%E5%80%BC%E7%9A%84%EF%BC%89%E3%80%82%E5%85%AC%E5%BC%8F%EF%BC%9AAVG-SUM-COUNT\"><span class=\"toc-text\"># 作用：计算指定字段在查询结构中出现的个数（不计算NULL值的）。公式：AVG &#x3D; SUM &#x2F; COUNT</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%9AGROUP-BY\"><span class=\"toc-text\"># 基本使用：GROUP  BY</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%88%97%E5%88%86%E7%BB%84%EF%BC%9AGROUP-BY\"><span class=\"toc-text\"># 使用多个列分组：GROUP  BY</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#HAVING-%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\"># HAVING() 的使用</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#SQL%E5%BA%95%E5%B1%82%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">SQL底层执行原理：</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">存储过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#1-%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">1.创建存储过程</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2-%E8%AE%BE%E7%BD%AE%E7%BB%93%E6%9D%9F%E7%AC%A6%E5%90%88\"><span class=\"toc-text\">2.设置结束符合</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#3-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">3.存储过程的调用</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89\"><span class=\"toc-text\">存储函数的使用（用户自定义的使用）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%AF%94%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E5%92%8C%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">对比存储函数和存储过程</span></a></li></ol></li></ol>","author":{"name":"陈花花","slug":"blog-author","avatar":"https://files.catbox.moe/wioly8.jpg","link":"/","description":"一位正在重塑和新增知识的测试人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"多表查询","uid":"2f35a19b4bc2eb8b3ed2288c836011ca","slug":"MySQL/mysql连表查询","date":"2023-01-07T07:39:29.707Z","updated":"2023-01-07T07:42:41.025Z","comments":true,"path":"api/articles/MySQL/mysql连表查询.json","keywords":null,"cover":"https://files.catbox.moe/l8sn6i.png","text":"多表查询 笛卡尔积(或交叉连接)的理解。 笛卡尔乘积是一个数学运算。假设我有两个集合X和Y,那么X和Y的笛卡尔积就是×和Y的所有可能组合,也就是第一个对象来自于x,第二个对象来自于Y的所有可能。组合的个数即为两个集合中元素个数的乘积数。 SQL99：CROSS JOIN 表示交叉...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"MYSQL","slug":"MYSQL","count":3,"path":"api/categories/MYSQL.json"}],"tags":[{"name":"MYSQL","slug":"MYSQL","count":2,"path":"api/tags/MYSQL.json"},{"name":"多表查询","slug":"多表查询","count":1,"path":"api/tags/多表查询.json"}],"author":{"name":"陈花花","slug":"blog-author","avatar":"https://files.catbox.moe/wioly8.jpg","link":"/","description":"一位正在重塑和新增知识的测试人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Docker 镜像的使用","uid":"1e85ed2976471a124c7c5c4dd3f1cabd","slug":"docker/Docker 镜像的使用","date":"2023-01-03T07:15:43.000Z","updated":"2023-01-04T12:47:40.221Z","comments":true,"path":"api/articles/docker/Docker 镜像的使用.json","keywords":null,"cover":"https://www.helloimg.com/images/2023/01/03/oCD5cE.png","text":"列出镜像列表我们可以使用 docker images 来列出本地主机上的镜像 $ docker images 选项说明 REPOSITORY: 表示镜像的仓库源 TAG: 镜像的标签 IMAGE ID: 镜像ID CREATED: 镜像的创建时间 SIZE: 镜像大小 同一仓库源...","link":"","photos":[],"count_time":{"symbolsCount":828,"symbolsTime":"1 mins."},"categories":[{"name":"Docker","slug":"Docker","count":1,"path":"api/categories/Docker.json"}],"tags":[{"name":"Docker","slug":"Docker","count":1,"path":"api/tags/Docker.json"},{"name":"镜像","slug":"镜像","count":1,"path":"api/tags/镜像.json"},{"name":"images","slug":"images","count":1,"path":"api/tags/images.json"}],"author":{"name":"陈花花","slug":"blog-author","avatar":"https://files.catbox.moe/wioly8.jpg","link":"/","description":"一位正在重塑和新增知识的测试人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}